//лабораторная работа №1 по курсу Dec-C100
/*
	В результате выполнения данной работы слушатель получает много мелких но необходимых
	для дальнейшей работы навыков, поэтому задание построено как последовательность 
	закомментированных блоков, которые требуется последовательно раскомментировать, 
	отвечая  при этом на поставленные вопросы.

	Примерная последовательность действий при отладке проекта:
	1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст программы;
	2. откомпилируйте (Build/Compile  ***.cpp или Ctrl+F7)
		Замечание: этот этап явно вызывать необязательно, но полезно для начинающего 6
			программиста, т.к. позволяет увидеть ошибки (errors) и предупреждения
			(warnings), возникающие при компиляции данного конкретного файла;
	3. скомпонуйте проект(Build/Build ***.exe или F7)
		Замечание 1: этот этап тоже необязателен, но настоятельно рекомендуем, т.к. 
			позволяет перекомпилировать только измененные файлы и в случае отсутствия
			ошибок всегда полезно посмотреть на выдаваемые компилятором замечания;
		Замечание 2: перед тем, как строить проект, неплохо убедиться  в том, что 
			исполняемый код будет содержать информацию для отладчика - 
				(Build/Configuration Manager.../Configuration - Debug - тип сборки проекта);
	4. поставьте на интересующих Вас строках исходного кода точки останова (breakpoints) - F9 или 
		просто кликните левой кнопкой на левой серой полосе окна редактирования; 
	5. запустите программу в режиме отладки 
		(Debug/Start... или  F5);
	6."Перемещаться" по коду во время отладки можно по шагам (от строки к строке). Для этого можно использовать клавишу F10.
	7. Кроме того, можно переходить от одной "точки останова" к другой посредством F5.
	8. ВАЖНО!!! Когда программа останавливается на некоторой "точке останова", то код инструкций, находящихся на соответствующей строке
       еще не выполнен! Для того, чтобы он выполнился, требуется сделать "шаг", т.е. нажать клавишу F10 или кнопку Step Over. 	   

  Замечание: для перечисленных выше действий приведены комбинации клавиш и соответствующие 
		пункты меню, однако во многих случаях гораздо быстрее то же самое можно сделать с 
		помощью кнопок на Tool Bar, в чем слушатель может преуспеть самостоятельно.

*/

#include  <climits>
#include <cfloat>



int nTwin=1;			//глобальная переменная
extern int nTest;		//объявление переменной nTest с ключевым словом extern. 
namespace TwinSpace { int nTwin = 2; }	//переменная объявлена в
						//пространстве имен - TwinSpace

#define	  stop __asm nop	//с помощью макроподстановки задаем "пустую" команду.
							//Эта макроподстановка нужна только для того, чтобы
							//можно было поставить на этой строке точку останова.

int main()
{
 //**********************************************************
	//Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	//следите за значениями переменных и интерпретируйте результат (помните, что 
	//количество байт, отводимых под int, системо-зависимо).
	//Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	//данных, а также на внутреннее представление отрицательных целых чисел.

	//Рядом с каждой строкой кода напишите комментарий, в котором укажите значение
	//переменной ПОСЛЕ выполнения соооветствующей инструкции
	//Помните, что если Вы поставили точку останова на какой-то строке, то отладчик
	//остановится ДО выполнения инструкции
	//чтобы продвигаться по коду пошагово, можно использовать клавишу F10 или кнопку Step Over

	//Для того, чтобы во ВРЕМЯ ОТЛАДКИ наблюдать за значениями переменных, можно использовать окошки "Autos", "Locals", "Watch"
	// окошко "Watch" удобно тем, что тем можно вводить не только имена наблюдаемых переменных, 
	//но и выражения, которые Вы хотели бы вычислить
	// Для того, чтобы увидеть 16-ричное представление значения, надо в контекстном меню  одного из окошек "Autos", "Locals", "Watch"
	// выбрать флажок Hexadecimal Display, для того, чтобы вернуться к 10-чному представлению - снять флажок Hexadecimal Display

	//Подсказка: очень удобно для просмотра значений  не самим набирать текст, а копировать его из окна просмотра
	
	
	char cByte = 'A';// cByte после выполнения: 0x41 ('A' в кодировке ASCII), тип: char.
	cByte = 0x42; // cByte после выполнения: 0x42 ('B' в кодировке ASCII), тип: char.
	cByte = 66; // cByte после выполнения: 66 ('B' в кодировке ASCII), тип: char.
	cByte = -1; // cByte после выполнения: 255 (беззнаковая интерпретация -1), тип: char.
	
	unsigned char ucByte = 0x41; // ucByte после выполнения: 0x41 ('A' в кодировке ASCII), тип: unsigned char.
	ucByte = 'B'; // ucByte после выполнения: 0x42 ('B' в кодировке ASCII), тип: unsigned char.
	ucByte = -1; // ucByte после выполнения: 255 (беззнаковая интерпретация -1), тип: unsigned char.
	int iInt = 0xffffffff; // iInt после выполнения: -1, тип: int.
	unsigned int uiInt = 0xffffffff; // uiInt после выполнения: 4294967295 (максимальное значение для беззнакового int), тип: unsigned int.
	float fFloat = 1.f; //fFloat после выполнения: 1.0, тип: float.
	double dDouble = 1.; // dDouble после выполнения: 1.0, тип: double.

	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.
	

	double d = 0.1234567890123456789123456789; // после выполнения: 0.1234567890123456789123456789, тип: double.
	float  f = d; //f после выполнения: 0.12345679104328155517578125 (потеря точности из-за использования float), тип: float.

	
	d = 1.; // d после выполнения: 1.0, тип: double.
	d = 0.999999999999999999999999999999999; // d после выполнения: 0.9999999999999999999999999999, тип: double.

	stop
	
	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)

	wchar_t cw = L'Ф'; //// cw после выполнения: значение 'Ф' в кодировке wchar_t, тип: wchar_t.
	size_t n = sizeof(cw); // n после выполнения: размер переменной типа wchar_t в байтах: 4 байта

	stop


// **************************************************************
	//Задание 2a. Неявное приведение типов данных.
	//Объясните разницу результата при выполнении (1) и (2):
	//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

	iInt = 1;
	double dDouble1 = iInt / 3; // после выполнения: 0 (так как iInt и 3 - целочисленные значения, результат целочисленного деления), тип: double

	double dDouble2 = iInt / 3.;	//после выполнения: 0.333333 (так как iInt стало типа double из-за деления на значение типа double), тип: double.


	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.
	//
	short sShort;
	dDouble = fFloat = iInt = sShort = cByte = 3.3 / 3;
	/*Результат выполнения:
	cByte: 1, тип: char.
	sShort: 1, тип: short.
	iInt: 1, тип: int.
	fFloat: 1, тип: float.
	dDouble: 1, тип: double.
	*/

	cByte = sShort = iInt = fFloat = dDouble = 3.3 / 3;
	/*
	Результат выполнения:
	dDouble: 1, тип: double.
	fFloat: 1, тип: float.
	iInt: 1, тип: int.
	sShort: 1, тип: short.
	cByte: 1, тип: char.
	*/

	//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор
	//Используйте оператор приведения типа static_cast

	iInt = 257;
	cByte = iInt; // Явное приведение: `cByte = static_cast<char>(iInt);`
	//cByte после выполнения: 1, тип: char.
	unsigned char cN1 = 255, cN2 = 2, cSum;
	cSum = cN1 + cN2; //cSum после выполнения: 1 (беззнаковое переполнение, так как cSum типа unsigned char), тип: unsigned char.

	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор

	int iSum = cN1 + cN2; //iSum после выполнения: 257 (переполнение не происходит, так как cN1 и cN2 приводятся к типу int перед сложением), тип: int.
	iInt = 257;
	cByte = static_cast<char>(iInt);
	// Явное преобразование: cByte = static_cast<char>(iInt);
	// cByte после выполнения: 1, тип: char.

	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит

	char c1 = 0xff, c2 = 2;
	unsigned char uc1 = 0xff, uc2 = 2;
	int iSum1 = c1 + c2;   //iSum1 после выполнения: -1 (переполнение, так как c1 типа char и знаковый), тип: int.
	int iSum2 = uc1 + uc2; //iSum2 после выполнения: 1 (знаковое расширение не происходит, так как uc1 и uc2 типа unsigned char), тип: int.



	stop
	
// ***********************************************************
	//Задание 2b. Явное приведение типов данных.
	//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
	// Напишите явно преобразования, которые неявно выполняет компилятор

    int nTmp = 100, nn = 3;
	dDouble = 3.3 + nTmp / nn; // (3) = 4.3


	// Явное преобразование типов, которые неявно выполняет компилятор:
	// dDouble = static_cast<double>(3.3 + static_cast<double>(nTmp) / static_cast<double>(nn));

	// Получение результата без потери точности с помощью оператора явного приведения типа:
	double dDouble3 = static_cast<double>(3.3) + static_cast<double>(nTmp) / static_cast<double>(nn); // (4)
	//В строке (3), компилятор выполняет операции сложения и деления с участием целых чисел, что может привести к потере точности. В результате переменная dDouble будет иметь значение 4.3, но это значение уже содержит неточности из-за целочисленного деления.

	//Чтобы получить результат без потери точности, в строке (4) используется явное приведение типов к double перед выполнением операций.



// *******************************************************
		// Задание 3. Область действия, область видимости и
			//				время существования переменных

		
	// Задание 3.1.
	// В этом фрагменте фигурируют четыре переменных с одним и тем же именем 
	// nTwin - одна глобальная, вторая определена в своем пространстве имен, 
	// (определены выше в начале модуля) третья - локальная внутри функции main(), 
	// четвертая - вложенная локальная внутри блока. 
	//   В данном задании требуется в выделенных местах фрагмента определить и откомментировать,
	// к какой из четырех переменных идет обращение (к глобальной, из пространства имен, к локальным),
	//а также факт существования и видимости для всех четырех

	//	Для выполнения задания рекомендуется пользоваться окнами "Locals" и "Watches"
	// Подсказка: - в окно "Watches" можно поместить как nTwin
	//			так и ::nTwin, впрочем как и TwinSpace::nTwin

		// Обратите внимание на небольшой "глюк" отладчика. Хотя локальная переменная nTwin
		// до следующей строки еще не определена (и формально даже не существует), но место
		// под нее в стеке функции main уже выделено (и там мусор). Если теперь в  окно 
		// "Watches" поместить просто nTwin, то отладчик будет показывать значение этой, еще 
		// не объявленной локальной переменной (что-то вроде -858993460 или 0xcccccccc), 
		// хотя должен формально показывать значение глобальной переменной, объявленной ранее.
		// Компилятор при этом все вычисляет верно.
		// Если надо увидеть именно значение глобальной переменной, то надо явно указать в окне
		// "Watches" глобальную область видимости, т.е. написать там ::nTwin.
		// Примечание: вот еще один аргумент за то, чтобы не создавать конфликты имен.

	nTwin = 100; // Обращение к глобальной переменной nTwin.
	TwinSpace::nTwin = 300; // Обращение к переменной nTwin в пространстве имен TwinSpace.
	nTwin += 1;	// Обращение к локальной переменной nTwin внутри функции main().
	int nTwin;		//Объявление новой локальной переменной nTwin внутри функции main().
	nTwin = 200;	// Использование локальной переменной nTwin внутри функции main().
	::nTwin = ::nTwin + 1;	// Обращение к глобальной переменной nTwin с использованием оператора разрешения области видимости (::)/
	{
		int nTwin; // Объявление новой локальной переменной nTwin внутри блока.
		nTwin = -1; // Использование локальной переменной nTwin внутри блока.
		::nTwin += 1; // Обращение к глобальной переменной nTwin с использованием оператора разрешения области видимости (::).
		TwinSpace::nTwin += 1; // Обращение к переменной nTwin в пространстве имен TwinSpace.
	}

	nTwin -= 1;  // Использование локальной переменной nTwin внутри функции main().

	// Задание 3.2
	
		//В этом фрагменте фигурируют  три переменных с одним и тем же именем
		// nTest - глобальная (определена в другом модуле) вторая - локальная внутри main,  третья - локальная внутри блока, 
	nTest = 1000;//Обращение к глобальной переменной nTest.
	int nTest = -2000;// Обращение к глобальной переменной nTest.
	{
		int nTest = 200; // Объявление и инициализация локальной переменной nTest внутри блока кода.
		nTest += 2; // Использование локальной переменной nTest внутри блока кода.
	}
	nTest += 2;			//Использование локальной переменной nTest внутри функции main.


	

// *******************************************************
	// Задание 4. Спецификатор класса памяти - static
	// а) Для каждой итерации цикла напишите значения пременных nLocal# и nStatic#.
	// б) Напишите, когда выполняется инициализация переменных?
	// в) Поясните (в комментарии) разницу между способом инициализации 
	//     переменных nStatic1 и nStatic2 
	
	for (int i = 0; i < 3; i++)
	{
		static int nStatic1 = 100;
		int nLocal1 = 100;
		int nLocal2 = 200;
		static int nStatic2 = (nLocal2 += 1) * 2;
		nStatic1 += 1;
		nStatic2 += 1;
		nLocal1 += 1;
		//  Выведите на каждой итерации значения nLocal1, nLocal2, nStatic1, nStatic2  на консоль  и заполните табличку
		/*
				Итерация 1:
				nLocal1=101
				nLocal2=201
				nStatic1=101
				nStatic2=202

				Итерация 2:
				nLocal1=101
				nLocal2=201
				nStatic1=102
				nStatic2=203

				Итерация 3:
				nLocal1=101
				nLocal2=201
				nStatic1=103
				nStatic2=204
		*/
		//nStatic1 инициализируется один раз при первом входе в цикл (статическая инициализация), и потом значение сохраняется между итерациями цикла.

		//nStatic2 инициализируется при каждой итерации цикла, потому что ее инициализация зависит от nLocal2, который изменяется в каждой итерации.
	}


	//Поведение переменной nStatic1 не изменится, потому что она инициализируется один раз при первом входе в цикл (статическая инициализация), и значение сохраняется между итерациями цикла.

	//Переменная nStatic1 инициализируется при первом входе в цикл значением 100, а затем увеличивается на 1 при каждой итерации цикла.
	for (int i = 0; i < 3; i++)
	{
		static int nStatic1; // Неинициализированная static переменная, по умолчанию инициализирована нулем.
		nStatic1 = 100;
		int nLocal1 = 100;
		nStatic1 += 1;
		nLocal1 += 1;
		/*
			Итерация 1:
			nLocal1=101
			nStatic1=101

			Итерация 2:
			nLocal1=101
			nStatic1=102

			Итерация 3:
			nLocal1=101
			nStatic1=103
		*/
	}



// *******************************************************
	// Задание 5. Перечисления - enum
	// Обратите внимание на явную и неявную инициализацию констант
	// Выполняя задание по шагам, следите за значениями, которые
	// принимает переменная myColors


	enum eColors
	{
		BLACK,
		BLUE,
		GREEN,
		RED = 5,
		YELLOW,
		WHITE = RED + 4
	};

	eColors myColors;  // Объявление переменной типа eColors
	myColors = BLACK;  // Присваивание значения BLACK
	myColors = BLUE;   // Присваивание значения BLUE
	myColors = GREEN;  // Присваивание значения GREEN
	myColors = RED;    // Присваивание значения RED
	myColors = YELLOW; // Присваивание значения YELLOW
	myColors = WHITE;  // Присваивание значения WHITE

	int nnn = BLACK;   // Присваивание значения BLACK целочисленной переменной
	nnn = BLUE + YELLOW; // Использование именованных констант в выражении


	// myColors = 1; // Ошибка при компиляции, так как 1 не является значением из перечисления.
	myColors = static_cast<eColors>(1); // Модифицированное выражение, чтобы избежать ошибки компиляции.


	// myColors = 123; // Ошибка при компиляции, так как 123 не является значением из перечисления.
	// Но можно использовать static_cast:
	myColors = static_cast<eColors>(123);

	stop
	


// *******************************************************
	// Задание 6.1 Логический тип bool
	// Выполняя задание по шагам, следите за значениями
	// переменной b и интерпретируйте результат. Напишите эти значения в комментариях

	int nNumber = 1;
	bool b = (nNumber != 0); // true, так как nNumber не равно 0

	b = (nNumber == 0); // false, так как nNumber не равно 0

	b = (nNumber > 0); // true, так как nNumber больше 0

	b = (nNumber > 1); // false, так как nNumber не больше 1

	b = 5; // true, так как любое ненулевое значение в условии считается true

	int tmp = b + 1; // tmp = 2, так как b (true) при преобразовании к int станет 1
	//Компилятор обычно интерпретирует true как 1 и false как 0 при преобразовании к целому типу.


// *******************************************************
	// Задание 7. Модификатор const и переменные

	{
		//Раскомментируйте следующие две строчки и объясните (в комментариях)
		//ошибки при компиляции 

		{
			// при объявлении константной переменной с использованием const, вы должны инициализировать её сразу. Когда попытка инициализации происходит позже, как в вашем коде, это вызывает ошибку компиляции.
			const int nN = 1; // Теперь переменная nN константная и инициализирована сразу.
		}

		//Исправьте определение константной переменной так, чтобы компилятор не выдавал ошибку
	}


	return 0;//код завершения приложения
}	// Конец функции main()

