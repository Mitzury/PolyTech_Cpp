/*************************************************************
	Практическое занятие №3. Директивы препроцессора.
							Указатели.
*************************************************************/

#include <iostream>
#include <tchar.h>
#include <cmath>
#include "stdafx.h"

#include "1.h"

#ifdef _DEBUG
#include "1.h"
#else
#include "2.h"
#endif


#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
#define MAX(A, B) ((A) > (B) ? (A) : (B))

#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку

int _tmain()
{
	// ********************************************************
		//Задание 1. Директивы препроцессора

		//1.1. Использование "математических" макросов стандартной библиотеки:
		//в заголовочном файле <cmath> (который в свою очередь включает старый
		//файл math.h) определены часто используемые математические
		//константы, например M_PI. Воспользуйтесь этой константой для
		//вычисления длины окружности.
		//Обратите внимание: определения констант в свою очередь тоже заключены
		//в директивы условной трансляции. Что еще, кроме подключения заголовочного
		//файла, требуется сделать???
	// *******************************************************

	double radius = 5.0;
	double circumference = 2.0 * M_PI * radius;

	std::cout << "Длина окружности: " << circumference << std::endl;


	//1.2.Макросы с параметрами.
	//1.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	{
		float l1 = LENGTH(1 + 2);   // должно быть 18.8495
		float l2 = 1 / LENGTH(2);   // должно быть 0.07957

		std::cout << "Длина окружности 1: " << l1 << std::endl;
		std::cout << "Длина окружности 2: " << l2 << std::endl;
		stop
	}
	// *******************************************************

		//1.2.2 (B) определите макрос MAX(A, B)  для вычисления б'ольшего
		//значения из двух.
#define MAX(A, B) ((A) > (B) ? (A) : (B))

	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно

	int i = 10, j = 12, k;
	k = MAX(i, j);        // i=10 j=12 k=12
	k = MAX(j, i) * 2;    // i=10 j=12 k=24
	k = MAX(j, i + 3);      // i=10 j=12 k=15
	k = MAX(i--, j++);    // i=9  j=13 k=12
	//Этот вариант макроса не создает побочные эффекты, так как каждое вхождение A и B обернуто в круглые скобки, и оператор ++ и -- применяется только к i и j, соответственно.

	//Теперь результаты более предсказуемы, и в случае MAX(i--, j++), i уменьшается до 9, а j увеличивается до 13, и k устанавливается в максимальное значение между 9 и 13, что равно 13.


// *******************************************************

	//1.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???

#define EXCHANGE(X, Y) do { int temp = X; X = Y; Y = temp; } while (0)

	int x1 = 1, y1 = -1;
	EXCHANGE(x1, y1);  // x1=-1, y1=1

	int x2 = 100, y2 = -100;
	EXCHANGE(x2, y2);  // x2=-100, y2=100
	//Этот макрос использует временную переменную temp, чтобы обменять значения X и Y. Обратите внимание, что этот макрос безопасен при обмене переменными любого целочисленного типа.

// *******************************************************


	//1.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?
#define NNN
#define MMM

	int iNN;
#if defined NNN && defined MMM
	iNN = 0;
#elif defined MMM
	iNN = 1;
#elif defined NNN
	iNN = 2;
#else
	iNN = -1;
#endif
	stop


		// *******************************************************

			//Задание 1.4. Загляните в Project -> Properties -> диалоговая панель
			//- Property Pages -> C\C++  -> Preprocessor -> Preprocessor definitions.
			//В опциях командной строки в зависимости от мишени сборки проекта
			//(Debug или Release) может быть определено с помощью ключа /D
			//имя _DEBUG. С помощью директив условной
			//трансляции напишите фрагмент кода, который в зависимости от типа
			//мишени выводит с помощью cout разный текст на консоль. Проверьте
			//при разных мишенях сборки.

			//Пусть
			//для мишени Debug в процессе выполнения данного участка
			//кода на экран выводится информация об
			//имени файла, номере строки с функцией вывода, дате и времени 
			//компиляции файла, содержащего данную функцию вывода,
			//а также имя функции, содержащей данную строку.

			//Для мишени Release должна быть просто выведена строка
			//"Release configuration!"

#ifdef DEBUG
#define DEBUG_INFO \
	std::cout << "Debug configuration!" << std::endl \
	<< "File: " << __FILE__ << std::endl \
	<< "Line: " << __LINE__ << std::endl \
	<< "Function: " << __func__ << std::endl \
	<< "Compilation date and time: " << __DATE__ << " " << __TIME__ << std::endl;
#else
#define DEBUG_INFO std::cout << "Release configuration!" << std::endl;
#endif

	//Подсказка: для получения нужной информации зайдите в online справку
	//(Help -> View Help), выберете язык C++ и в поле поиска введите 
	//следующую ключевую фразу: Predefined Macros
	// Или пройдите по ссылке: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-160




// *******************************************************
	{
		//Задание 1.5  Управляя определенностью идентификатора _UNICODE и используя
			//возможности заголовочного <tchar.h>, определим и проинициализируем переменную,
			//которая может становиться как однобайтовой, так и расширенной без 
			//изменения исходного текста.
			//С помощью отладчика проверьте результат (определите значение в 10-чной и 16-чной системе счисления).

		//Подсказка: Для того, чтобы настроить проект на работу с  некоторой кодировкой, надо:
			//1)Выбрать Project -> Properties. Будет открыта диалоговая панель  Property Pages  
			//2)Configuration Properties -> Advansed-> Advansed Properties -> Character Set
			//3) установить флаг "Use Unicode Character Set", если требуется Unicode
			//4) установить флаг "Not Set", если требуется  работа с однобайтовыми символами.
			// 
	//Замечание:  В следующие 4 строки не надо вносить никаких изменений, только добавить комментарии 
	// В комментариях указать значения кодов символов в 10-чной и 16-чной системе счисления

		TCHAR ch1 = __T('A'); // ch1=65 (0x41)
		size_t s1 = sizeof(ch1); // s1=2 (в Unicode используется 2 байта на символ)
		TCHAR ch2 = __T('Ф'); // ch2=1060 (0x424) в Unicode
		TCHAR ch3 = 'Ф'; // ch3=1060 (0x424) в Unicode
		// Вывод результатов в консоль
		std::wcout << L"ch1=" << ch1 << L" s1=" << s1 << L" ch2=" << ch2 << L" ch3=" << ch3 << std::endl;
	}
	// *******************************************************
	{
		//Задание 1.6
		//Создайте файл предкомпиляции.
		//Особого смысла в этой простой лаб. работе это не имеет.
		// Задание предлагается для знакомства с техникой создания файла предкомпиляции

		//В случае нашей лабораторной работы можно поместить директивы препроцессора, 
		//подключающие библиотечные файлы в отдельный заголовочный файл и создать файл предкомпиляции.
		//По умолчанию при создании нового проекта в Visual Studio в проекте указывается имя stdafx.h(VS 2019) 
		// в качестве имени файла предкомпилированного заголовка. Имя этого файла может быть изменено, но с целью упрощения мы этого делать не будем.
		//Надо выполнить несколько шагов :
		//1) Создать файл stdafx.h и поместить в него заголовки библиотечных файлов, которые будут использованы в работе
		//2) Создать файл реализации stdafx.cpp  и в него поместить единственную строку   #include "stdafx.h" 
		//3) В клиентском файле с исходным кодом подключить заголовочный файл stdafx.h
		//4) Задать ключи для файлов реализации :
		//		для stdafx.cpp - / Yc
		//		для lab3.cpp - / Yu
		// 
		// Компиляционные ключи в Visual Studio:
		//#include "stdafx.h"
		///stdafx.cpp: /Ycstdafx.h
		///lab3.cpp: /Yulab3.h

	}
	// ********************************************************
		//Задание 2.Заголовочные файлы. Директива #include
		//Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
		//В каждом заголовочном файле объявите перечисление с одинаковыми именами
		//констант, но сопоставьте именованным константам разные значения, например:
		//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
		//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
		//констант из 1.h, а в RELEASE-версии значениями констант из 2.h

		/*
		#include "1.h"

		#ifdef _DEBUG
		#include "1.h"
		#else
		#include "2.h"
		#endif
		*/


		// ********************************************************
		/*
			//Задание 3. Указатели
			//Объявите  несколько объектов разных типов и проинициализируйте их.
			//Объявите указатели соответствующих типов и проинициализируйте их

			int integerValue = 42;
			double doubleValue = 3.14;
			char charValue = 'A';

			//адресами заданных объектов.
			//Выполняя задание, с помощью отладчика посмотрите, какие значения
			//будут присвоены переменным-указателям и на что эти указатели
			//"указывают"

			int* pInt = &integerValue;
			double* pDouble = &doubleValue;
			char* pChar = &charValue;



		*/
		// *******************************************************

			//Задание 4. Арифметика указателей. Операция разыменования указателя.
			//Выполняя задание, следите за изменением значений
			//указателей и значений объектов, на которые они указывают.
			//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = { 1,3 };
		int* pn = &nAr[0];
		(*pn)++;
		pn++;

		char cAr[] = { 'A','B','C','D' };
		char* pc = &cAr[0];
		(*pc) = (*pc) + 5;
		pc = pc + 3;

		double dAr[3] = { 1.0,2.0 };
		double* pd1 = &dAr[0];
		double* pd2 = pd1;
		(*pd2) += 2;
		pd2 += 2;

		// Объяснение результатов выполнения операции вычитания двух указателей
		pd1 = &dAr[0];         // = адрес первого элемента
		pd2 = &dAr[1];         // = адрес второго элемента
		int nNumber = pd2 - pd1;  // = 1, т.к. pd2 находится на один элемент впереди pd1

		// Сравнение указателей pd2 и pd1 и вывод результатов сравнения с помощью cout
		std::cout << "Comparison of pd2 and pd1: " << (pd2 > pd1) << std::endl;  // 1, т.к. pd2 находится впереди pd1


	}


	// *******************************************************

		//Задание 5. Void-указатель. 
		//5.1. Выполняя задание, посмотрите - какие значения присваиваются
		//void-указателю. Обратите внимание: средствами отладчика Вы
		//не можете посмотреть значения, на которые "указывает"
	{
		void* pVoid;  // объявление void-указателя
		int nObject3 = 5;
		char cObject3 = 'A';
		int* pInt = &nObject3;
		pVoid = &nObject3;
		pVoid = &cObject3;
		pVoid = pInt;

		//Прежде, чем раскомментировать следующую строчку, вспомните:
		//что нужно сделать, чтобы выражение стало корректным 	
		pInt = static_cast<int*>(pVoid);
	}

	// *******************************************************

		//5.2. При выполнении следующего фрагмента посмотрите, какие неприятности
		//могут Вас ожидать при явном приведении типа void-указателя,
		//который в момент времени (1) указывает на double, к типу 
		//указателя на int (2) 
{

	void* pVoid;
	double dObject3 = 33.33;
	pVoid = &dObject3;  // (1)


	// При выполнении следующего фрагмента посмотрите, какие неприятности
	// могут Вас ожидать при явном приведении типа void-указателя,
	// который в момент времени (1) указывает на double, к типу
	// указателя на int (2)
	int nTmp = *(static_cast<int*>(pVoid));  // (2)

	std::cout << "nTmp: " << nTmp << std::endl;

	//При выполнении данного фрагмента произойдет некорректное приведение типа указателя. 
	// Так как pVoid указывает на объект типа double, а не int, приведение типа будет ошибочным, и результат (nTmp) будет неопределенным.

	//Приведение типа static_cast<int*>(pVoid) может привести к непредсказуемым результатам и нежелательным побочным эффектам, 
	// поэтому в подобных ситуациях требуется осторожность. Операции с указателями должны соблюдать семантику данных, которые они указывают.
}
	stop

// *******************************************************


	//Задание 6.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int n1 = 1;

    //Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1
	int* pn = &n1;

    //Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn
	int** ppn = &pn;

    //Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn
	int*** pppn = &ppn;
  
	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2
	int n2 = ***pppn;
	//int n2=...
	std::cout << "n2: " << n2 << std::endl;
	//Cоздаются указатели pn, ppn и pppn, а затем с их помощью получается значение объекта n1, которое присваивается переменной n2.

	stop
//*********************   Дополнительное задание   ****************************************************
//Задание 7 (*)  
// Выполните задание 2 по курсовой работе 
// описание задания находится в файле "Задание (игра Змейка)_2 (змейка на экране)_3.docx"
// Каждое задание выполняется в отдельном проекте
// Рекомендация:
// Все проекты (project), связанные с курсовой работой имеет смысл помещать в одно решение (solution)
//*****************************************************************************************************


	return 0;
}//end main
