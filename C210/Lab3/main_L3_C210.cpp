//Стандартная библиотека шаблонов - STL 
//Контейнеры стандартной библиотеки - vector
//Итераторы

#include <iostream>
#include <vector>
#include "MyString.h"
#include "Point.h"

#pragma warning(disable: 4786)


#define	  stop __asm nop

template <typename T>
void printVectorInfo(const std::vector<T>& vec) {
	std::cout << "Size: " << vec.size() << std::endl;
	std::cout << "Capacity: " << vec.capacity() << std::endl;
	std::cout << "Max Size: " << vec.max_size() << std::endl;
	std::cout << "Elements: ";
	for (const auto& elem : vec) {
		std::cout << elem << " ";
	}
	std::cout << std::endl << std::endl;
}

using namespace std;
int main()
{
setlocale(LC_ALL, "Russian");
// Контейнер стандартной библиотеки vector 
//////////////////////////////////////////////////////////////////////
//Создание векторов. 

//Создайте следующие вектора:
//пустой вектор целых чисел - vInt и проверьте с помощью функции size(),
//что его размер нулевой. 


	// создание пустого вектора целых чисел
	std::vector<int> vInt;
	// проверка размера
	std::cout << "Chapter 1" << std::endl;
	std::cout << "Size of vInt: " << vInt.size() << std::endl; 
	

//Раскомментируйте следующий фрагмент, подумайте - все ли корректно
//Если есть некорректности, - исправьте

	//vInt.front()=1;
	//Попытка доступа к front() элементу до заполнения вектора будет некорректной, так как вектор пустой:


//С помощью функции push_back() в цикле заполните вектор какими-либо значениями.
//На каждой итерации цикла следите за размером вектора с помощью методов
//size(), capacity(), max_size() и выводите значения элементов. 
//
//Подсказка: так как такая проверка понадобится Вам и в следующих заданиях,
//напишите шаблон функции, которая для вектора, содержащего элементы любого типа
//выводит его "реквизиты" и значения элементов на консоль.

	std::vector<int> myVector;

	std::cout << "Chapter 1.1" << std::endl;
	for (int i = 0; i < 10; ++i) {
		myVector.push_back(i * 2);
		printVectorInfo(myVector);
	}


//вектор вещественных - vDouble1 с заданным Вами начальным размером  и
//проверьте результат с помощью созданного Вами шаблона. Как будут
//проинициализированы элементы вектора?

	// Создаем вектор вещественных чисел с начальным размером 5
	std::vector<double> vDouble1(5);

	// Печатаем информацию о векторе
	std::cout << "Chapter 2" << std::endl;
	printVectorInfo(vDouble1);

//вектор объектов типа MyString с начальным размером - 5 элементов
//и инициализацией каждого элемента строкой "A"
//C помощью функции at() а также с помощью оператора
//индексирования []  измените значения каких-либо элементов.
//Попробуйте "выйти" за границы вектора с помощью at() и
//с помощью []. 

	
	std::vector<MyString> vecMyString(5, MyString("A"));

	std::cout << "Chapter 3" << std::endl;
	// Изменяем значения некоторых элементов с помощью функции at()
	try {
		vecMyString.at(2).set("B");
		vecMyString.at(4).set("C");
		vecMyString.at(11).set("C");
	}
	catch (const std::out_of_range& e) {
		std::cerr << "Обнаружено исключение out_of_range: " << e.what() << std::endl;
	}

	// Изменяем значение элемента с помощью оператора индексирования []
	vecMyString[0].set("X");

	// Попробуем обратиться к элементам за пределами вектора
	try {
		vecMyString.at(10).set("D");
	}
	catch (const std::out_of_range& e) {
		std::cerr << "Обнаружено исключение out_of_range: " << e.what() << std::endl;
	}

	// Печатаем значения всех элементов вектора
	for (const auto& elem : vecMyString) {
		std::cout << elem.get() << std::endl;
	}


//вектор вещественных - vDouble3, который является копией элементов
// [0,5) массива вещественных чисел dMas. Предворительно массив dMas 
//нужно создать и проинициализировать!

	std::cout << "Chapter 4" << std::endl;
	const int size = 5;
	double dMas[size];
	for (int i = 0; i < size; ++i) {
		dMas[i] = i * 1.1; // Произвольная инициализация значений массива
	}

	// Создаем вектор vDouble3, который является копией элементов массива dMas
	std::vector<double> vDouble3(dMas, dMas + size);

	// Печатаем значения элементов вектора vDouble3
	std::cout << "Values in vDouble3: ";
	for (const auto& elem : vDouble3) {
		std::cout << elem << " ";
	}
	std::cout << std::endl;


//вектор вещественных - vDouble4, который является копией элементов
// [2,5) вектора vDouble3. 

	std::vector<double> vDouble3_1 = { 1.1, 2.2, 3.3, 4.4, 5.5 };
	// Создаем вектор vDouble4, который является копией элементов с индексами от 2 до 4 вектора vDouble3
	std::vector<double> vDouble4(vDouble3_1.begin() + 2, vDouble3_1.begin() + 5);

	std::cout << "Chapter 4.1" << std::endl;
	// Печатаем значения элементов вектора vDouble4
	std::cout << "Values in vDouble4: ";
	for (const auto& elem : vDouble4) {
		std::cout << elem << " ";
	}
	std::cout << std::endl;


	//вектор элементов типа Point - vPoint1 а) с начальным размером 3. Какой конструктор
	//будет вызван для каждого элемента?
	//b) vPoint2 с начальным размером 5 и проинициализируйте каждый элемент координатами (1,1).

	std::vector<Point> vPoint2(5, Point(1, 1));

	std::cout << "Chapter 5" << std::endl;
	// Выводим координаты каждого элемента
	for (const auto& point : vPoint2) {
		std::cout << "x: " << point.x << ", y: " << point.y << std::endl;
	}


//вектор указателей на Point - vpPoint с начальным размером 5
//Подумайте: как корректно заставить эти указатели "указывать" на объекты Point

//Подсказка: для вывода на печать значений скорее всего Вам понадобится
//а) специализация Вашей шаблонной функции
//б) или перегрузка operator<< для Point*
	std::cout << "Chapter 5.1" << std::endl;
	{
		// Создаем вектор указателей на объекты типа Point
		std::vector<Point*> vpPoint(5);

		// Создаем объекты типа Point и добавляем указатели на них в вектор
		for (int i = 0; i < 5; ++i) {
			vpPoint[i] = new Point(i + 1, i + 1);
		}

		// Выводим значения объектов, на которые указывают элементы вектора
		for (const auto& point : vpPoint) {
			std::cout << point << std::endl;
		}

		// Освобождаем память, выделенную под объекты Point
		for (auto& point : vpPoint) {
			delete point;
		}

	}//Какие дополнительные действия нужно предпринять для такого вектора?


///////////////////////////////////////////////////////////////////////
//Резервирование памяти.
//Подумайте, всегда ли верны приведенные ниже проверки?
		/*
		{
		size_t n=...
		vector<int> v(n);
		v.resize(n/2);
		if(v.capacity() == n) //true?
		}
		*/
		// Это утверждение будет истинным, если вектор v после вызова resize(n / 2) не изменяет свою емкость. 
		// Верно, если емкость вектора не меняется после уменьшения размера, но это не всегда гарантируется, 
		// так как вектор может переместить свои элементы в другое место памяти, если емкости не хватает для уменьшения.

		/*
		{
		int n=...
		size_t m=...
		vector<int> v(n);
		v.reserve(m);
		if(v.capacity() == m) //true?
		}
		*/
		// Это утверждение будет верным, если после вызова reserve(m) емкость вектора v действительно равна m.

		/*
		{
		vector<int> v(3,5);
		v.resize(4,10); //значения?
		v.resize(5); //значения?
		}
		*/
		//После выполнения этого блока кода v будет содержать элементы [5, 5, 5, 10, 0].
		

//Создайте два "пустых" вектора с элементами
//любого (но одного и того же типа) типа. 
//В первом векторе зарезервируйте память под 5 элементов, а потом заполните
//его значениями с помощью push_back.
//Второй вектор просто заполните значениями посредством push_back.
//Сравните размер, емкость векторов и значения элементов

		std::cout << "Chapter 6" << std::endl;
		std::vector<int> v1;
		std::vector<int> v2;

		v1.reserve(5); // Резервирование памяти под 5 элементов

		// Заполнение первого вектора значениями с помощью push_back
		for (int i = 0; i < 5; ++i) {
			v1.push_back(i * 2);
		}

		// Заполнение второго вектора значениями с помощью push_back
		for (int i = 0; i < 5; ++i) {
			v2.push_back(i * 3);
		}

		// Вывод информации о первом векторе
		std::cout << "v1.size() = " << v1.size() << ", v1.capacity() = " << v1.capacity() << std::endl;
		std::cout << "v1 elements: ";
		for (const auto& elem : v1) {
			std::cout << elem << " ";
		}
		std::cout << std::endl;

		// Вывод информации о втором векторе
		std::cout << "v2.size() = " << v2.size() << ", v2.capacity() = " << v2.capacity() << std::endl;
		std::cout << "v2 elements: ";
		for (const auto& elem : v2) {
			std::cout << elem << " ";
		}
		std::cout << std::endl;



		//!!! shrink_to_fit - Уменьшение емкости вектора.
		//Для любого вектора из предыдущего задания требуется уменьшить емкость
		//до size.




		//Создание "двухмерного вектора" - вектора векторов
		//Задан одномерный массив int ar[] = {11,2,4,3,5};
		//Создайте вектор векторов следующим образом:
		//вектор vv[0] - содержит 11 элементов со значением 11
		//vv[1] - содержит 2,2
		//vv[2] - содержит 4,4,4,4
		//...
		//Распечатайте содержимое такого двухмерного вектора по строкам
		//с помощью:

		//std::cout<<vv<<std::endl;
	stop

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			//Вставка элемента последовательности insert().
			//Реализуйте функцию, которая должна вставлять новый элемент
				//в начало вектора только при условии, что в векторе такого
				 //значения еще нет.
			//Проверьте работоспособность функции - в вектор vChar2 вставьте в начало вектора символ только при
			//условии, что в векторе такого символа еще нет.
				 //например: vChar2 - abc 
				 //При попытке вставить 'a' попытка должна быть проигнорирована
				 //При попытке вставить 'q' vChar2 - qabc 



			//Реализуйте функцию, которая должна вставлять новый элемент
				 //перед каждым элементом вектора
			//Проверьте работоспособность функции - вставьте перед каждым элементом вектора vChar2 букву 'W'



		///////////////////////////////////////////////////////////////////
			//Напишите функцию, которая должна удалять только повторяющиеся последовательности.
			//Например: было - "qwerrrrty12222r3", стало - "qwety1r3"




		stop

		///////////////////////////////////////////////////////////////////

			//Удаление элемента последовательности erase()
			//Напишите функцию удаления из любого вектора всех дублей 
				 //Например: было - "qwerrrrty12222r3", стало - "qwerty123"





		///////////////////////////////////////////////////////////////////
			//Создайте новый вектор таким образом, чтобы его элементы стали
			//копиями элементов любого из созданных ранее векторов, но расположены
			//были бы в обратном порядке






		///////////////////////////////////////////////////////////////////

			//Задание 1. Списки. Операции, характерные для списков.
			//Создайте пустой список из элементов Point - ptList1 и наполните
			//его значениями с помощью методов push_back(),
			//push_front, insert()


			//Напишите шаблон функции, которая будет выводить элементы
			//ЛЮБОГО КОНТЕЙНЕРА на печать. Проверьте работу шаблона на контейнерах
			//vector и list. Подсказка - хотелось бы увидеть тип контейнера.


			//Сделайте любой из списков "реверсивным" - reverse()


			//Создайте список ptList2 из элементов Point таким образом, чтобы он стал 
			//копией вектора элементов типа Point, но значения элементов списка располагались
			//бы в обратном порядке 



			//Отсортируйте списки  ptList1 и ptList2 - методом класса list - sort()
			//по возрастанию.
			//Подумайте: что должно быть перегружено в классе Point для того, чтобы
			//работала сортировка





		stop

		//Объедините отсортированные списки - merge(). Посмотрите: что
		//при этом происходит с каждым списком.


		stop

		//Исключение элемента из списка - remove()
		//Исключите из списка элемент с определенным значением.
		//Подумайте: что должно быть перегружено в классе Point?


		//Исключение элемента из списка, удовлетворяющего заданному условию:
		//любая из координат отрицательна - remove_if(). 


		//Исключение из списка подряд расположенных дублей - unique(). 

		stop

		///////////////////////////////////////////////////////////////////
			//Задание 2.Очередь с двумя концами - контейнер deque

			//Создайте пустой deque с элементами типа Point. С помощью
			//assign заполните deque копиями элементов вектора. С помощью
			//разработанного Вами в предыдущем задании универсального шаблона
			//выведите значения элементов на печать



			//Создайте deque с элементами типа MyString. Заполните его значениями
			//с помощью push_back(), push_front(), insert()
			//С помощью erase удалите из deque все элементы, в которых строчки
			//начинаются с 'A' или 'a'




		return 0;
}