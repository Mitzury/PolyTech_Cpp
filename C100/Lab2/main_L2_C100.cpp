/*************************************************************
	Практическое занятие №2. 
	
	Инструкции (условная, выбор, циклы)
	Логические операторы, тернарный (условный) оператор 
	Побитовые операторы.
							
*************************************************************/

#include <iostream>
#include <iomanip>
#include <bitset>


#define	  stop __asm nop	//с помощью директивы препроцессора задаем макроподстановку
/***************************************************************/
int main()
{
	setlocale(LC_ALL, "Russian");
// ********************************************************
	//Задание 1. Условная инструкция if-else.Переключатель switch 

	//Задание 1.1 Напишите фрагмент кода, который переводит код символа, 
	//хранящийся в переменной ch в противоположный регистр.
	//Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
	//или нажал другую клавишу, которой символ не соответствует

	//Подсказка: работаем только с символами английского алфавита, для которого в таблице
	// кодов ASCII код каждой буквы нижнего регистра на 0x20 больше кода 
	// соответствующей буквы верхнего регистра.
	
	//Обратите внимание, что в кодировочной таблице между буквами верхнего и нижнего регистра 
        //расположены некоторые иные символы
	{
		// Сформируйте значение переменной ch с помощью потока ввода
		char ch;
		std::cout << "Введите символ: ";
		std::cin >> ch;

		// Проверяем, является ли символ буквой английского алфавита
		if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')) {
			// Если символ верхнего регистра, переводим его в нижний, и наоборот
			ch = (ch >= 'A' && ch <= 'Z') ? (ch + 32) : (ch - 32);
			std::cout << "Измененный символ: " << ch << std::endl;
		}
		else {
			// Если введенный символ не является буквой английского алфавита
			std::cout << "Вы ввели не букву английского алфавита." << std::endl;
		}
		stop
	}
	//Задание 1.2 Напишите фрагмент кода, который реализует с помощью if (if/else)
	//следующую логику: 
	//если x меньше или равен 0, y=0
	//если x больше 0 но меньше 1, то y=x,
	//если x больше или равен 1, то y=1
	//Подумайте: какого типа должны или могут быть x и y?
	{
		// Объявляем переменные x и y
		double x, y;

		// Получаем значение переменной x с помощью потока ввода
		std::cout << "Введите значение x: ";
		std::cin >> x;

		// Реализация условий с использованием if/else
		if (x <= 0) {
			y = 0;
		}
		else if (x < 1) {
			y = x;
		}
		else {
			y = 1;
		}

		// Выводим результат
		std::cout << "Значение y: " << y << std::endl;
		//x и y могут быть типа double или float, так как условия включают в себя сравнение с числами, которые могут иметь дробную часть.

	stop
	}
	//Задание 1.3 Напишите фрагмент кода, который реализует с помощью switch
	//следующую логику: 
	//в переменной cInput типа char дано значение символа,введенного любым способом.
	//Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
	//переменной у значение переменной x
	//Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
	//переменной у значение (x * 2)
	//Если любой другой симол, то вывести сообщение об ошибке
	{
		char cInput;
		double x_1, y_1;

		// Получаем значение переменной cInput с помощью потока ввода
		std::cout << "Введите символ (y/n): ";
		std::cin >> cInput;

		// Реализация условий с использованием switch
		switch (tolower(cInput)) {
		case 'y':
			y_1 = x_1;
			break;
		case 'n':
			y_1 = x_1 * 2;
			break;
		default:
			std::cout << "Ошибка: введен неверный символ." << std::endl;
			return 1;  // Завершаем программу с ошибкой
		}

		// Выводим результат
		std::cout << "Значение y: " << y_1 << std::endl;


	stop
	}
	// Вариант 2

	{
		char cInput;
		double x_1, y_1;

		// Получаем значение переменной cInput с помощью потока ввода
		std::cout << "Введите символ (y/n): ";
		std::cin >> cInput;

		// Реализация условий с использованием switch
		switch (cInput) {
		case 'y':
		case 'Y':
			y_1 = x_1;
			break;
		case 'n':
		case 'N':
			y_1 = x_1 * 2;
			break;

		default:
			std::cout << "Ошибка: введен неверный символ." << std::endl;
			return 1;  // Завершаем программу с ошибкой
		}

		// Выводим результат
		std::cout << "Значение y: " << y_1 << std::endl;


		stop
	}

// ********************************************************
	//Задание 2. Логические операторы.
	// В Григорианском календаре (которым мы все пользуемся) високосный год
	// определяется по следующему алгоритму: високосным является каждый четвертый год,
	// но каждый сотый високосным НЕ является, при этом каждый 400-й год все таки 
	// високосный. Т.е. 1823 - не високосный, 1824 - високосный, 1900 - не високосный,
	// 2000 - високосный.
	// Напишите фрагмент кода, такой что:
	// логическая переменная isLeapYear принимает значение true, если год, заданный
	// переменной year - високосный.

	// Примечание: НЕ надо пользоваться инструкциями if-else, switch и тернарным оператором 
	//             НАДО написать логическое выражение в одну строку.
	//(*)если возникнут затруднения при решении задачи, то можно сначала решить ее с помощью if-else,
	// а потом уже выполнить предложенное задание.
	{
		int year = 1823;
		//int year = 1824;
		//int year = 1900;
		//int year = 2000;

		//Вычислили значение 
		// Вычисляем значение логической переменной isLeapYear
		bool isLeapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);

		// Выводим результат
		std::cout << "Год " << year << (isLeapYear ? " - високосный" : " - не високосный") << std::endl;
		// проверили значение в отладчике
		stop
	}


// *******************************************************
	//Задание 3. Тернарный оператор.  
	//С помощью тернарного оператора найдите максимальное из трех значений

	//(*)если возникнут затруднения при решении задачи, то можно сначала решить ее с помощью if-else,
	// а потом уже выполнить предложенное задание.
	{
		int a = 15;
		int b = 30;
		int c = 20;

		// Используем тернарный оператор для нахождения максимального значения
		int max = (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);

		// Выводим результат
		std::cout << "Максимальное значение: " << max << std::endl;
	stop	
	}

// ********************************************************
	//Задание 4. Циклы.

	//Задание 4.1 Напишите фрагмент кода, который реализует с помощью for
	//следующую логику: найти сумму заданного диапазона целых чисел.
	//Задайте границы с помощью потока ввода (или прямо в коде).
	//Предусмотрите защиту от ввода нижней границы больше, чем верхней.
	{
		// Сформируем границы диапазона с помощью потока ввода
		int lowerBound, upperBound;

		std::cout << "Введите нижнюю границу диапазона: ";
		std::cin >> lowerBound;

		std::cout << "Введите верхнюю границу диапазона: ";
		std::cin >> upperBound;

		// Проверим корректность значений
		if (lowerBound > upperBound) {
			std::cout << "Ошибка: нижняя граница больше верхней." << std::endl;
			return 1;  // Возвращаем ненулевое значение, чтобы показать ошибку
		}

		// Вычислим сумму чисел в диапазоне
		int sum = 0;
		for (int i = lowerBound; i <= upperBound; ++i) {
			sum += i;
		}

		// Выведем результат
		std::cout << "Сумма чисел в диапазоне [" << lowerBound << ", " << upperBound << "] равна: " << sum << std::endl;

		// 4.1 Вариант 2 
		char cInput;
		double x_1, y_1;
		std::cout << "Введите символ (y/n): ";
		std::cin >> cInput;
		switch (cInput) {
		case 'y':
		case 'Y':
			y_1 = x_1;
			break;
		case 'n':
		case 'N':
			y_1 = x_1 * 2;
			break;
		default:
			std::cout << "Ошибка: введен неверный символ." << std::endl;
			return 1;
		}


		std::cout << "Значение y: " << y_1 << std::endl;

	stop
	}

	//Задание 4.2 Напишите фрагмент кода, который реализует с помощью do-while
	//следующую логику: на каждой итерации цикла ввести с консоли целое значение
	// и покинуть цикл, если значение удовлетворяет условию: 
	// значение больше или равно 10 и четное.

	int value;

	do {
		std::cout << "Введите целое значение: ";
		std::cin >> value;

		// Покинуть цикл, если значение больше или равно 10 и четное
	} while (!(value >= 10 && value % 2 == 0));
	std::cout << "Введено корректное значение: " << value << std::endl;

	
	//Замечание: проверка на четность с использованием операции остатка от деления
	//нацело генерирует очень неэффективный код. Попробуйте реализовать альтернативный
	//вариант 2 
	{
	int value;
		do {
			std::cout << "Введите целое значение: ";
			std::cin >> value;
		} while (!(value >= 10 && (value & 1) == 0)); // используем & 1, чтобы проверить младший бит числа value. 
													  //Если результат value & 1 равен 0, это означает, что число четное, потому что младший бит равен 0. 
													  //Если результат равен 1, это означает, что число нечетное, потому что младший бит равен 1.
		std::cout << "Введено корректное значение: " << value << std::endl;
		int x_2 = 0;
		double sum_1 = 0.0;
		while (sum_1 <= 1.7) {
			x_2 = x_2 + 1;
			sum_1 = sum_1 + 1.0 / x_2;
		}
		std::cout << "Значение x, при котором sum > 1.7: " << x_2 << std::endl;
	}
	stop


	//Задание 4.3 Напишите фрагмент кода, который реализует с помощью while
	//следующую логику: исходно int x = 0; 
	//на каждой итерации x=x+1, sum=sum+1/x
	//найти значение x, при котором sum>1.7
	{
		int x_2 = 0;
		double sum_1 = 0.0;
		while (sum_1 <= 1.7) {
			x_2 = x_2 + 1;
			sum_1 = sum_1 + 1.0 / x_2;
		}
		std::cout << "Значение x, при котором sum > 1.7: " << x_2 << std::endl;
	stop
	}
// ********************************************************
//Задание 5 Побитовая арифметика (and, or, xor, not), сдвиги.
	//5.1 

	size_t num_bit;
	std::cout << "Введите номер бита: ";
	std::cin >> num_bit;

	// б) В переменной val обнулите значение бита, заданного переменной num_bit
	{
		char val = 0xFF;
		val &= ~(1 << num_bit);
		std::cout << "Значение после обнуления бита: " << std::hex << +val << std::endl;
	}

	// в) В переменной val определите значение бита, заданного переменной num_bit
	{
		char val = 0xAA;
		int bit_value = (val >> num_bit) & 1;
		std::cout << "Значение бита: " << bit_value << std::endl;
	}

	// г) В переменной val установите в 1 значение бита, заданного переменной num_bit
	{
		char val = 0;
		val |= (1 << num_bit);
		std::cout << "Значение после установки бита: " << std::hex << +val << std::endl;
	}


	//5.2 
	{
	//Если число кодируется более чем одним байтом, то важно, 
	//в каком порядке байты записываются в памяти компьютера или передаются по линиям связи.			//В архитектуре x86  используется порядок от младшего к старшему (англ. little-endian)
	//Для протоколов TCP/IP стандартным является порядок от старшего к младшему (англ. big-endian)  
	//Задайте значение x, например:

		{
			int x = 0xA1B2C3D4;
			// Поменяем байты переменной x в памяти местами
			x = ((x & 0xFF000000) >> 24) | ((x & 0x00FF0000) >> 8) | ((x & 0x0000FF00) << 8) | ((x & 0x000000FF) << 24);
			std::cout << "Значение x после перестановки байт: 0x" << std::hex << std::setw(8) << std::setfill('0') << x << std::endl;
		}
	//байты числа в памяти следуют в порядке от младшего к старшему
	//поменяйте местами байты так, чтобы они следовали в памяти в обратном порядке 
	//(от старшего к младшему)
	//Например, если x= 0xA1B2C3D4, то после перестановки получим 0xD4C3B2A1
	
	stop
	}
// ********************************************************
	//Задание 6 Побитовая арифметика (and, or, xor, not), сдвиги.
	//6.1 
	{
		//Задайте значение y, например, с помощью потока ввода 
		//или с помощью числового литерала в двоичном или 16-ричном виде

		int y;

		// Задайте значение y, например, с помощью потока ввода или числового литерала
		std::cout << "Значение y в двоичном виде: " << std::bitset<sizeof(int) * 8>(y) << std::endl;

		// шаблонный класс std::bitset, который предоставляет возможность работать с битами. sizeof(int) * 8 определяет размер переменной типа int в битах, 
		// и std::bitset используется для представления этого количества битов в бинарной форме.y - это переменная, 
		// значение которой будет представлено в двоичной форме.

		//С помощью побитовых операторов и операторов сдвига:
		//выведите значение "y"  на консоль в двоичном виде, например:
		// если y==9, то 
		// 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)

	}
	//6.2

		//Выведите значение "y"  на консоль в двоичном виде, 
		//пропустив незначащие нули, например:
		// если y==9, то результат  1 0 0 1
		{
			int y;


			std::cout << "Значение y в двоичном виде: ";

			bool leadingZeros = true;

			for (int i = sizeof(int) * 8 - 1; i >= 0; --i) {
				int bit = (y >> i) & 1;

				if (bit == 1) {
					leadingZeros = false;
				}

				if (!leadingZeros) {
					std::cout << bit;
				}
			}

			if (leadingZeros) {
				std::cout << "0";
			}

			std::cout << std::endl;


		}


	//6.3 (*)
	{
		//Дана целая переменная
			int y;

			// Задайте значение y, например, с помощью потока ввода

			std::cout << "Было:  ";
			for (int i = sizeof(int) * 8 - 1; i >= 0; --i) {
				std::cout << ((y >> i) & 1);
			}
			std::cout << std::endl;

	//"Сдвиньте" все единицы в этой переменной вправо, например:
	//было:   0100 1111 0000 0000 0110 1111 0000 0010
	//стало:  0000 0000 0000 0000 0000 1111 1111 1111
	//Выведите на консоль полученное значение в двоичном виде ( можно на печати не разделять тетрады пробелом)
	// "Сдвиньте" все единицы в этой переменной вправо
			int shiftedY = 0;
			int bitCount = 0;

			for (int i = 0; i < sizeof(int) * 8; ++i) {
				int bit = (y >> i) & 1;

				if (bit == 1) {
					shiftedY |= (1 << bitCount);
					bitCount++;
				}
			}
			std::cout << "Стало: ";
			for (int i = sizeof(int) * 8 - 1; i >= 0; --i) {
				std::cout << ((shiftedY >> i) & 1);
			}
			std::cout << std::endl;

		stop
	}
	//6.4 (*)
	//Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
		
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не сасают" 
	{
		short sNum = 0x8008;
		short sRes;

		// Примеры операций:

		// 0x7ff7
		sRes = sNum & 0x7ff7;

		// 0x8ff8
		sRes = sNum | 0x1000;

		// 0x0008
		sRes = sNum & 0x000F;

		// 0x7f08
		sRes = sNum | 0x7F00;

		// 0xf001
		sRes = sNum ^ 0x7009;

		// 0x0010
		sRes = sNum & 0x001F;

		std::cout << "Было: 0x" << std::hex << sNum << std::endl;
		std::cout << "Желаемое: 0x" << std::hex << sRes << std::endl;

		stop
	}
//*********************   Дополнительное задание   ****************************************************
//Задание 7 (*)  
// Выполните задание 1 по курсовой работе 
// описание задания находится в файле "Задание (игра Змейка)_1 (клавиатурный ввод)_3.docx"
// Каждое задание выполняется в отдельном проекте
// Рекомендация:
// Все проекты (project), связанные с курсовой работой имеет смысл помещать в одно решение (solution)
//*****************************************************************************************************
	return 0;//код завершения приложения
}	// Конец функции main()
