
/*************************************************************
	Практическое занятие №2 курс С110. Функции.
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции

*************************************************************/
#include <iostream>
#include <tchar.h>
//#include <cstdio>
//#include <cstdarg>
#include "other.h"
#include <chrono>


#define	  stop __asm nop

int _tmain()
{

	//Задание 1. 
	//массивы в качестве аргументов функции.
	//Напишите два варианта функции печати элементов
	//1. встроенного двумерного массива
	const size_t N = 3;
	const size_t M = 4;

	int ar[N][M] = 
	{
	 {1, 2, 3, 4},
	 {5, 6, 7, 8},
	 {9, 10, 11, 12}
	};


	//Замечание:
	// Задать значения элементам массива можно либо с помощью списка инициализации, 
	// либо с помощью кода 
	// 

	void PrintArray(int(&ar)[N][M]); {
		for (size_t i = 0; i < N; ++i) {
			for (size_t j = 0; j < M; ++j) {
				std::cout << ar[i][j] << ' ';
			}
			std::cout << '\n';
		}
	}

//2. динамического двумерного массива (обе размерности вычисляются)



	//	PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);  //Важно! первый параметр- имя двумерного (!) массива


		//2. динамического двумерного массива (обе размерности вычисляются)
		//Замечание:
		// Задать значения элементам массива можно с помощью кода 


	/////////////////////////////////////////////////////////////////////////////
		//Задание 2.
		//Передача имени встроенного двумерного массива в качестве параметра функции.
				//Напишите две взаимодополняющие друг друга функции:
				//1.  ... DayOfYear(...)
				//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
				//в порядковый день года(возвращаемое значение)
				//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
				// (принимает год и порядковый день года в качестве параметров и должна сформировать
				// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)

				//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
				//для проверки "високосности" года имеет смысл создать функцию (isLeepYear)
				//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
				//данные приведенного ниже двухмерного массива nDayTab


	int nDayTab[2][12] = {
		{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
		{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
	};


	bool isLeapYear(int year) {
		return ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0));
	}


	size_t DayOfYear(size_t day, size_t month, size_t year, int(&nDayTab)[2][12]) {
		size_t numDay = day;

		for (size_t i = 0; i < month - 1; ++i) {
			numDay += nDayTab[isLeapYear(year)][i];
		}

		return numDay;
	}


	void DayOfMonth(size_t numDay, size_t year, int(&nDayTab)[2][12], size_t & day, size_t & month) {
		size_t i = 0;

		while (numDay > nDayTab[isLeapYear(year)][i]) {
			numDay -= nDayTab[isLeapYear(year)][i];
			++i;
		}

		month = i + 1;
		day = numDay;
	}

	size_t day = 15, month = 3, year = 2023;


	size_t numDay = DayOfYear(day, month, year, nDayTab);
	std::cout << "Day of year: " << numDay << std::endl;


	size_t resultDay, resultMonth;
	DayOfMonth(numDay, year, nDayTab, resultDay, resultMonth);
	std::cout << "Day: " << resultDay << ", Month: " << resultMonth << std::endl;

	return 0;

	//Проверьте работоспособность обеих функций с помощью следующего фрагмента:

	//Вызов функции DayOfYear   может выглядеть так:

	//size_t day = ..., month = ..., year = ...;
	//size_t numDay = DayOfYear(day, month, year, nDayTab);  //Важно! последний параметр- имя двумерного (!) массива


	//Проверка результата обратной функцией DayOfMonth        //Важно! последний параметр- имя двумерного (!) массива
	//...

	stop
		/////////////////////////////////////////////////////////////////////////////
			//Задание 3.
			//Задание 3а. Функции с переменным числом параметров.
			//Напишите функцию (дана заготовка VarArgs, не использующая
			// макросы), которая принимает переменное число аргументов
			// типа int и выводит на печать число принятых параметров и
			// их значения.
			// Признаком конца списка является нулевое значение.
		/*
			int nN1=5, nN2=11, nN3=4, nN4=7, nN5=-1;
			VarArgs(nN1,0);
			VarArgs(nN1,nN2,0);
			VarArgs(nN1,nN2,nN3,nN4,nN5,0);
			stop


			//Задание 3б. Модифицируйте функцию 3а с помощью макросов
			// va_start, va_arg, va_end
		*/
		///////////////////////////////////////////////////////////////////
		//Тема "Старые" потоковые функции стандартной библиотеки
		//Задание 4.1 С помощью функции scanf сформирйуте три коэффициента: A,B,C


		//Задание 4.2. Выведите таблицу значений y=A*x*x + B*x + C
		//при изменении x в диапазоне -2 до +2 с шагом 0.5

		///////////////////////////////////////////////////////////////////
			//Тема Указатели на функции

			//Задание 5. Указатель на функцию. "Калькулятор".
			//Напишите функции:
			//1)Sum - принимает два значения double и возвращает сумму
			//этих значений
			//2)Sub- принимает два значения double и возвращает разность
			//этих значений
			//3)Mul - *
			//4)Div - /
			//5)а для возведения в степень можете использовать функцию стандартной библиотеки
			//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
			//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
			//		вариантов этой функции, а Вам потребуется сформировать указатель на 
			//		double pow(double, double);

			//Предоставьте пользователю	следующую возможность:
			//пока пользователь хочет пользоваться услугами Вашего калькулятора,
			//он может вводить два значения и знак операции
			//а Вы выводите результат. Результат получаете посредством вызова
			//соответствующей Вашей функции по указателю.
			//Предусмотрите возможность ввода непредусмотренного знака операции


		stop
		///////////////////////////////////////////////////////////////////
			//Задание 6. Указатель на функцию в качестве аргумента.
			//Дана заготовка функции сортировки любых объектов - Sort.
			//Функция принимает следующие параметры:
			//1) указатель на первый сортируемый элемент
			//2) количество сортируемых элементов
			//3) размер элемента в байтах
			//4) указатель на функцию перестановки элементов
			//5) указатель на функцию сравнения элементов

			//6a. Напишите функцию перестановки двух целых значений -
			// SwapInt, которая принимает два void указателя и 
			//меняет значения местами

			//Напишите функцию сравнения двух целых значений -
			// CmpInt, которая принимает два void указателя и
			//возвращает int результат сравнения: 
			//<0 - первый элемент меньше, чем второй
			//=0 - равны
			//>0 - первый элемент больше, чем второй
			/*
				int nAr[]=...	//массив для сортировки

				//Печать исходного массива

				//Вызов сортировки
				int nTotal=...			//количество элементов в массиве
				Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

				//Печать результатов сортировки

				stop
			*/
			/*
			//Задание 6б. По аналогии с 6а создайте вспомогательные
			//функции - SwapDouble и CmpDouble и вызовите функцию Sort
			//для сортировки массива вещественных значений.
			*/

			/*
			//Задание 6в*. По аналогии с 6а создайте вспомогательные
			//функции - SwapStr и CmpStr и вызовите функцию Sort
			//для сортировки массива указателей на строки.

			const char* arStr[] = { "QQQ", "SDF", "ABC","Abba", "ENFR","En",. . . };

			//Замечание:

			//в массиве линейно лежат АДРЕСА строк, надо передать АДРЕС массива,
				Sort(reinterpret_cast<char*>(&arStr[0])), nTotal, sizeof(???), SwapStr, CmpStr);
			*/
			///////////////////////////////////////////////////////////////////
				/*
				//Задание 7. Массивы указателей на функцию.
				//Напишите несколько функций вида
				//const char* GetString1();
				//const char* GetString2();
				//const char* GetString3();
				//const char* GetString4();
				//const char* GetString5();

				//		...., каждая из функций возвращает указатель на свою строку
				//(подумайте - какой адрес Вы имеете право возвращать из функции)

				// Вам предоставлен код этих функций.
				//Подумайте:
				//1) все ли они корректны, если нет, то как исправить некорректность
				//2) может быть требуются какие-то дополнительные действия

				//Объявите и проинициализируйте массив указателей на функции
				//GetString1,GetString2...
				//Введите номер функции, которую Вы хотите вызвать:
					int n;



				//Вызовите функцию



				//Распечатайте результат


				*/


				////////////////////////////////////////////////////////////////////////////
					//Задание 8*.
					//Создайте одномерный массив (размерность вычисляется в процессе
					//выполнения программы), заполните его значениями.
					//Напишите функцию, которая добавляет в массив новое значение только (!) при условии,
					//что такого значения в массиве еще нет. 
					//Подсказка: при этом размер  массива должен увеличиться!
					//Для проверки напишите функцию, которая выводит значения всех элементов на экран
				///////////////////////////////////////////////////////////////////////////
				/*********************   Дополнительное задание   ****************************************************/
				//Задание 9 (*)
				// Выполните задание 8 по курсовой работе
				// описание задания находится в файле "Задание (игра Змейка)_8 (двумерный динамический массив поля)_3.docx"
				//*****************************************************************************************************


					return 0;
				}//main

