/*************************************************************
	Практическое занятие №4 курс С110. Рекурсивные функции.
	Использование структур для реализации односвязного списка

*************************************************************/
#include <iostream>
#include <cstdio>
#define stop __asm nop

#include "list.h"
#include "functions.h"



void main()
{
//Задание 1:	
//Рекурсивные функции.
	//1.1.Написать рекурсивную функцию вычисления суммы первых N натуральных чисел. 
	//1.2.Написать рекурсивную функцию вычисления количества цифр 10-чного натурального числа 
	//1.3.Написать рекурсивную функцию для вывода на экран строки в обратном порядке. 
	//1.4.Написать рекурсивную функцию для вывода на экран строки в прямом (!) порядке.
//Замечание:
	// Прототипы функций поместите в заголовочный файл functions.h, а реализации - в файл functions.cpp
	
	std::cout << "Sum of first 5 natural numbers: " << sumOfFirstN(5) << std::endl;
	std::cout << "Number of digits in 12345: " << countDigits(12345) << std::endl;
	
	std::string str = "Hello, World!";
	std::cout << "Reverse print: ";
	reversePrint(str);
	std::cout << std::endl;
	
	std::cout << "Forward print: ";
	forwardPrint(str);
	std::cout << std::endl;
//----------------------------------------------------------------------------------------------------------
//Задание 2:	
	//ПОДСКАЗКИ: в файле "Односвязный список (процедурный подход, подсказки)_2022.pdf" 
	
	//Односвязный список будет содержать данные целого типа.
	// 
	//2.1. В заголовочном файле list.h объявите структуру Node, описывающую узел односвязного списка. 
	//  
	//2.2. Разработайте следующие функции:
	//1) Добавление данных в список (в начало)
	//При добавлении элемента в начало списка будет изменяться значение указателя на голову.
	// Подумайте, как в вызывающий код вернуть это измененное значение

	//2) Удаление из списка одного элемента, данные которого совпадают с заданным значением
	// (первого, который встретился)
	//Подсказка:
	//при удалении элемента возможны следующие ситуации:
	// - удаляемый элемент является "головой"
	// - удаляемый элемент не является "головой"
	// - элемент в списке не найден 
	//В том случае, когда удаляемый элемент является "головой", значение указателя на голову изменяется.
	//Кроме измененного значения указателя на начало списка хотелось бы получать признак  выполнено удаление
	// или нет. Подумайте, как это осуществить.
	// 
	//3) Печать списка, начиная с "головы" 
	//   (порядок следования элементов будет обратным порядку заполнения). 

	//4) Печать списка, начиная с конца (рекурсивная функция). 
	//   (порядок следования элементов будет соответствовать порядку, 
	//	в котором заполнялся список.
	
	//Замечание:
	// Прототипы функций поместите в заголовочный файл list.h, а реализации - в файл list.cpp
	
	
	Node* myList = nullptr;
	
	myList = addToBeginning(myList, 3);
	myList = addToBeginning(myList, 2);
	myList = addToBeginning(myList, 1);
	
	std::cout << "Original List: ";
	printList(myList);
	
	if (removeFromList(myList, 2)) {
		std::cout << "Element 2 removed. Updated List: ";
		printList(myList);
	} else {
		std::cout << "Element 2 not found in the list.\n";
	}
	
	std::cout << "Reverse Print: ";
	printListReverse(myList);
	std::cout << std::endl;
	

	while (myList != nullptr) {
		Node* temp = myList;
		myList = myList->next;
		delete temp;
	}

//----------------------------------------------------------------------------------------------------------
//Задание 3:	
	//3.1. "Создайте" пустой односвязный список, задав указатель на его "голову"
	

	//3.2. Заполните список значениями
	
	//3.3. Выведите список на консоль 
	
	//3.4. Выведите список на консоль в порядке заполнения (рекурсивная функция)
	
	//3.5. Удалите из списка заданное значение. Предусмотрите проверку, когда: 
	// - удаляемый элемент является "головой"
	// - удаляемый элемент не является "головой"
	// - элемент в списке не найден 
	//
	//3.6. Выведите список на консоль 
	//  
	//3.7. Не забудьте освободить динамическую память.
	
	// 3.1
	Node* myList_1 = nullptr;
	
	// 3.2
	myList_1 = addToBeginning(myList, 3);
	myList_1 = addToBeginning(myList, 2);
	myList_1 = addToBeginning(myList, 1);
	
	// 3.3
	std::cout << "List: ";
	printList(myList_1);
	
	// 3.4
	std::cout << "List in original order: ";
	printListReverse(myList_1);
	std::cout << std::endl;
	
	// 3.5
	int valueToRemove = 2;
	if (removeFromList(myList_1, valueToRemove)) {
		std::cout << "Element " << valueToRemove << " removed. Updated List: ";
	} else {
		std::cout << "Element " << valueToRemove << " not found in the list.\n";
	}
	
	// 3.6
	std::cout << "Updated List: ";
	printList(myList_1);
	
	// 3.7
	while (myList != nullptr) {
		Node* temp = myList_1;
		myList_1 = myList_1->next;
		delete temp;
	}

}