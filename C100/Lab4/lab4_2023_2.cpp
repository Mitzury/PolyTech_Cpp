/*************************************************************
	Практическое занятие №4. Встроенные массивы.
							Простейшие алгоритмы сортировки и поиска.
							
*************************************************************/

#include <cstdlib>
#include <ctime>
#include <iostream>

#define	  stop __asm nop

int main()
//Задания, помеченные * не являются обязательными. Но выполнение их крайне желательно!!!
{
///////////////////////////////////////////////////////////////
//			Указатели (продолжение)                              
///////////////////////////////////////////////////////////////

		//Задание 1. Модификатор const. 
		//В каждом из заданий объявите указатель требуемого вида. 
		//Посредством каждого указателя попробуйте:
		//1) получить значение по адресу
		//2) записать новое значение по адресу
		//3) модифицировать указатель
//Замечания:
//1.операторы явного преобразования типа использовать не следует
//2.если компилятор не позволяет выполнить операцию, то комментируйте эту строку с пояснением

	// Задание 1a. Указатель является константой.
	int n = 42;
	const int* pConst = &n;
	// 1) Получить значение по адресу
	std::cout << "1a) Value at address: " << *pConst << std::endl;
	// 2) Записать новое значение по адресу (Невозможно, так как указатель pConst указывает на константное значение)
	// *pConst = 99;
	// 3) Модифицировать указатель (Возможно)
	pConst = nullptr;
	//Задание 1б. Указываемое значение является константой.
	int n_1 = 42;
	int* const pConstValue = &n_1;
	// 1) Получить значение по адресу
	std::cout << "1b) Value at address: " << *pConstValue << std::endl;
	// 2) Записать новое значение по адресу
	*pConstValue = 99;
	// 3) Модифицировать указатель (Невозможно, так как pConstValue является константой)
	// pConstValue = nullptr;

	stop

// *******************************************************


		//Задание 1в. И указатель, и указываемое значение
		//являются константами. 
		int n_2 = 42;
		const int* const pConstPointerAndValue = &n_2;

		// 1) Получить значение по адресу
		std::cout << "1v) Value at address: " << *pConstPointerAndValue << std::endl;

		// 2) Записать новое значение по адресу (Невозможно, так как указываемое значение является константой)
		// *pConstPointerAndValue = 99;

		// 3) Модифицировать указатель (Невозможно, так как указатель является константой)
		// pConstPointerAndValue = nullptr;

	stop

// *******************************************************


		//Задание 1г. Указатель на переменную, объявленную с
		//ключевым словом const. 
	const int nN = 1;
		const int* pConstPointerToConstVariable = &nN;

		// 1) Получить значение по адресу
		std::cout << "1g) Value at address: " << *pConstPointerToConstVariable << std::endl;

		// 2) Записать новое значение по адресу (Невозможно, так как переменная объявлена с const)
		// *pConstPointerToConstVariable = 99;

		// 3) Модифицировать указатель
		pConstPointerToConstVariable = nullptr;
	stop


//*******************************************************
	//Задание 1д. const  и void-указатель. 
	{
		//1) Что нужно сделать для того, чтобы следующее закомментированное выражение
		//стало корректным?
		const int n = 1; 
		// void* pn = &n;

	//  Чтобы следующее выражение стало корректным, необходимо выполнить явное приведение типа.
	const void* pn = static_cast<const void*>(&n);

	// Получить значение посредством void*
	// Прежде чем использовать значение, необходимо выполнить обратное приведение типа.
	int extractedValue = *static_cast<const int*>(pn);

	std::cout << "1d) Extracted value: " << extractedValue << std::endl;

	}
//*******************************************************

	//Задание 1е. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?
	const char* strLiteral = "Hello, World!";

	// Присвойте переменной типа char значение любого элемента строки.
	char ch = 'A';

	// Проверьте - возможно ли присвоить какое-либо значение по адресу,
	// задаваемому указателем?
	// Раскомментируйте следующую строку, чтобы увидеть ошибку компиляции:
	// strLiteral[0] = 'B'; // Ошибка компиляции, так как строковые литералы являются константами

	std::cout << "1e) Character from string literal: " << strLiteral[0] << std::endl;
	std::cout << "    Modified character: " << ch << std::endl;


	stop
//
// //*******************************************************
	//Задание 2. Явное преобразование указателя. 
	//Иногда возникает необходимость одни и те же данные интерпретировать по-разному,

	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 

	//Следовательно, возникает необходимость явного преобразования указателя. 

	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне

	//переменных и изменяйте пункт - Hexadecimal display !!!!!!!!!!!!!!!!!


	unsigned int nObject5 = 0x55667788;
	unsigned int* pnObject5 = &nObject5;

	unsigned char* pucObject5;

	// Раскомментируйте следующую строчку кода с использованием reinterpret_cast
	pucObject5 = reinterpret_cast<unsigned char*>(pnObject5); // (2)

	// Откомментируйте следующие строчки
	char cc = *(pucObject5++);  // Получаем первый байт значения nObject5
	std::cout << "Byte 1: " << std::hex << static_cast<int>(cc) << std::endl;

	cc = (*pucObject5)++;  // Увеличиваем значение второго байта
	std::cout << "Byte 2 after increment: " << std::hex << static_cast<int>(cc) << std::endl;

	cc = ++ * (pucObject5);  // Увеличиваем и читаем значение третьего байта
	std::cout << "Byte 3 after pre-increment: " << std::hex << static_cast<int>(cc) << std::endl;

	cc = *(++pucObject5);  // Увеличиваем указатель и читаем значение четвертого байта
	std::cout << "Byte 4 after incrementing pointer: " << std::hex << static_cast<int>(cc) << std::endl;


	stop

///////////////////////////////////////////////////////////////
//			Встроенные массивы                               
///////////////////////////////////////////////////////////////

	//Задание 3. 
	//Имеется одномерный встроенный массив, проинициализированный при объявлении 
	//Отсортируйте массив по возрастанию значений. 
	//Используйте "пузырьковую" сортировку  
	// Правильность решения проверьте с помощью отладчика

	{
			int ar[] = {5, 4, 7, 8, 1, 2, 6, 0, 10, 12, 77, 11, 6, 8, 33, 21, 1, 2, 3, 4};
			int size = sizeof(ar) / sizeof(ar[0]);

			for (int i = 0; i < size - 1; ++i) {
				for (int j = 0; j < size - i - 1; ++j) {
					if (ar[j] > ar[j + 1]) {
						
						int temp = ar[j];
						ar[j] = ar[j + 1];
						ar[j + 1] = temp;
					}
				}
			}

			std::cout << "Sorted Array: ";
			for (int i = 0; i < size; ++i) {
				std::cout << ar[i] << " ";
			}
			std::cout << std::endl;

	}
	
	
// *******************************************************
	//Задание 4  
	//в)Инициализация массива строковыми литералами:
	//Объявите одномерный массив УКАЗАТЕЛЕЙ и проинициализируйте его СТРОКОВЫМИ литералами . 
	//Выведите  массив на печать.
		const char* strArray[] = {
			"Hello",
			"World",
			"C++",
			"Arrays",
			"Pointers"
	};

	// Вывод массива на печать
	std::cout << "String Array:" << std::endl;
	for (const char* str : strArray) {
		std::cout << str << std::endl;
	}

// *******************************************************
	//Задание 5. 
	//a) Объявите одномерный неинициализированный массив ( размером N)
	const int N = 10;
	int myArray[N];
	//Задайте значения элементов с помощью генератора случайных чисел.
	srand(static_cast<unsigned>(time(0)));

	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	// int tmp= rand(); // получим случайное значение в диапазоне от 0 до RAND_MAX
    	//значение RAND_MAX задано в файле <stdlib.h>  и равно  0x7fff
	
	//если Вам требуется задать иные границы диапазона при генерации случайного числа, 
	//то это можно сделать так:
	//v1 = rand() % 100;         // v1 в диапазоне 0 - 99
	//v2 = rand() % 100 + 1;     // v2 в диапазоне 1 - 100
	//v3 = rand() % 30 + 1985;   // v3 в диапазоне 1985-2014 
	
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются "псевдослучайными", то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет "привязку" начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	//srand( time( 0 ) );

	for (int i = 0; i < N; ++i) {
		myArray[i] = rand() % 100; // Генерация случайного числа в диапазоне 0-99
	}
	// Выводим исходный массив на экран
	std::cout << "Original Array:" << std::endl;
	for (int i = 0; i < N; ++i) {
		std::cout << myArray[i] << " ";
	}
	std::cout << std::endl;

	// Сортируем массив по убыванию с помощью сортировки выбором
	for (int i = 0; i < N - 1; ++i) {
		int maxIndex = i;
		for (int j = i + 1; j < N; ++j) {
			if (myArray[j] > myArray[maxIndex]) {
				maxIndex = j;
			}
		}
		// Обмениваем значения элементов массива
		int temp = myArray[i];
		myArray[i] = myArray[maxIndex];
		myArray[maxIndex] = temp;
	}

	// Выводим отсортированный массив на экран
	std::cout << "Sorted Array (Descending):" << std::endl;
	for (int i = 0; i < N; ++i) {
		std::cout << myArray[i] << " ";
	}
	std::cout << std::endl;


// 
	
// *******************************************************

	//Задание 6. 
	//Объявите встроенный одномерный массив, состоящий из N элементов целого типа. 
	//Напишите фрагмент кода, который вводит целые числа с помощью
	//потока ввода в объявленный Вами массив, каждый раз ( на каждой итерации!)
	//упорядочивая полученное значение по возрастанию.
	//Для проверки выводите массив на консоль на каждой итерации`
	const int N_1 = 5; // Задайте необходимый размер массива
	int myArray_1[N_1];

	// Вводим целые числа в массив и упорядочиваем на каждой итерации
	for (int i = 0; i < N_1; ++i) {
		std::cout << "Enter an integer: ";
		std::cin >> myArray_1[i];

		// Упорядочиваем массив по возрастанию
		for (int j = i; j > 0 && myArray_1[j] < myArray_1[j - 1]; --j) {
			// Обмениваем значения элементов массива
			int temp = myArray_1[j];
			myArray_1[j] = myArray_1[j - 1];
			myArray_1[j - 1] = temp;
		}

		// Выводим текущее состояние массива
		std::cout << "Array after iteration " << i + 1 << ": ";
		for (int k = 0; k <= i; ++k) {
			std::cout << myArray_1[k] << " ";
		}
		std::cout << std::endl;
	}
	
// *******************************************************
	//Задание 7. 

	//Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:
	//очередное введенное значение помещается в массив только при условии, 
	//что там еще такого нет (то есть дубли игнорируются)

	const int N_2 = 5; // Задайте необходимый размер массива
	int myArray_2[N_2];
	int currentIndex = 0;

	// Вводим целые числа в массив (без дубликатов)
	while (currentIndex < N_2) {
		int value;
		std::cout << "Enter an integer: ";
		std::cin >> value;

		// Проверяем наличие дубликата в массиве
		bool isDuplicate = false;
		for (int i = 0; i < currentIndex; ++i) {
			if (myArray_2[i] == value) {
				isDuplicate = true;
				std::cout << "Duplicate ignored." << std::endl;
				break;
			}
		}

		// Если нет дубликата, добавляем значение в массив и сортируем
		if (!isDuplicate) {
			myArray_2[currentIndex] = value;
			++currentIndex;

			// Упорядочиваем массив по возрастанию
			for (int j = currentIndex - 1; j > 0 && myArray_2[j] < myArray_2[j - 1]; --j) {
				// Обмениваем значения элементов массива
				int temp = myArray_2[j];
				myArray_2[j] = myArray_2[j - 1];
				myArray_2[j - 1] = temp;
			}

			// Выводим текущее состояние массива
			std::cout << "Array: ";
			for (int k = 0; k < currentIndex; ++k) {
				std::cout << myArray_2[k] << " ";
			}
			std::cout << std::endl;
		}
	}

// *******************************************************
	//Задание 8
	//Объявите одномерный встроенный массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных 
	//чисел таким образом, чтобы в массиве были только символы '*' и '_'  
	
	//"сдвиньте звездочки" в начало массива, например:
	//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
	//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	//и распечатайте массив 

	const int N_3 = 10; // Задайте необходимый размер массива
	char myArray_3[N_3];

	// Инициализация генератора случайных чисел
	srand(time(0));

	// Заполнение массива символами '*' и '_'
	for (int i = 0; i < N_3; ++i) {
		myArray_3[i] = rand() % 2 == 0 ? '*' : '_';
	}

	// "Сдвиг звездочек" в начало массива
	int starCount = 0;
	for (int i = 0; i < N_3; ++i) {
		if (myArray_3[i] == '*') {
			// Обмен значениями с элементом, находящимся на позиции starCount
			char temp = myArray_3[i];
			myArray_3[i] = myArray_3[starCount];
			myArray_3[starCount] = temp;
			++starCount;
		}
	}

	// Вывод массива
	std::cout << "Array: ";
	for (int i = 0; i < N_3; ++i) {
		std::cout << myArray_3[i] << " ";
	}
	std::cout << std::endl;

// *******************************************************
	//Задание 9
	//объявите одномерный встроенный массив  из N элементов и проинициализируйте его.
	//а) сдвиньте все элементы массива вправо на 1 позицию
	//б) (Циклическая перестановка). Сдвиньте все элементы массива вправо на 1 позицию , 
	//но последний элемент не должен быть утерян. Его следут переместить в начало.
	//например,  { 5, 2, 11, 4, 23, 9 } ->  {9, 5, 2, 11, 4, 23 }

	//в)(Кольцевой буфер) выведите массив на печать, циклически "сдвинув" элементы вправо на 1 позицию.
	//При решении задачи не следует перемещать элементы массива, а надо использовать кольцевой буфер.
	// Одномерный массив можно "свернуть" в кольцо и считать, что за последним элементом следует начальный и
	// потом установить "новое" начало массива.

	const int N_4 = 6; // Задайте необходимый размер массива
	int myArray_4[N] = { 5, 2, 11, 4, 23, 9 };

	// а) Сдвигаем все элементы массива вправо на 1 позицию
	int temp = myArray_4[N - 1];
	for (int i = N_4 - 1; i > 0; --i) {
		myArray_4[i] = myArray_4[i - 1];
	}
	myArray_4[0] = temp;

	// Выводим результат
	std::cout << "a) Сдвигаем все элементы массива вправо на 1 позицию:" << std::endl;
	for (int i = 0; i < N_4; ++i) {
		std::cout << myArray_4[i] << " ";
	}
	std::cout << std::endl;

	// б) Циклическая перестановка
	temp = myArray_4[N - 1];
	for (int i = N_4 - 1; i > 0; --i) {
		myArray_4[i] = myArray_4[i - 1];
	}
	myArray_4[0] = temp;

	// Выводим результат
	std::cout << "б) Циклическая перестановка:" << std::endl;
	for (int i = 0; i < N_4; ++i) {
		std::cout << myArray_4[i] << " ";
	}
	std::cout << std::endl;

	// в) Кольцевой буфер (выводим циклически, не перемещая элементы)
	std::cout << "в) Кольцевой буфер:" << std::endl;
	for (int start = 0; start < N_4; ++start) {
		for (int i = 0; i < N_4; ++i) {
			std::cout << myArray_4[(start + i) % N_4] << " ";
		}
		std::cout << std::endl;
	}

// *****************************************************************************************************************
	//Задание 10 (*)
	//алгоритм "тасования колоды"
	//объявите одномерный встроенный массив  из N элементов и 
	// заполните  его неповторяющимися числами из заданного отрезка 
	//натурального ряда, расположенными в случайном порядке
//(Подсказки в файле Алгоритмы для лабораторной работы_4.pdf)
//Алгоритм:
//Массив  A [N] инициализируется последовательными значениями из отрезка, например [0,N-1]
//index=N-1, где index- максимальное значение индекса.

//В цикле по index выполняется перемешивание значений:
//	1. Генерируется случайное число  R из отрезка [0, index]
//	2. Выполняется обмен значений A[index]  и  A[R]
//	3. index=index -1
//	4. Если index==0, то конец
//	5. Переход к шагу 1    

	//Для того, чтобы выполнять это задание было интереснее, можно воспользоваться следующим массивом
	// массив текстовых эквивалентов  достоинства карт
const char* cards[] = { " 2\5", " 3\5", " 4\5", " 5\5", " 6\5", " 7\5", " 8\5", " 9\5", "10\5", " J\5", " Q\5", " K\5", " A\5",
	" 2\4", " 3\4", " 4\4", " 5\4", " 6\4", " 7\4", " 8\4", " 9\4", "10\4", " J\4", " Q\4", " K\4", " A\4",
	" 2\3", " 3\3", " 4\3", " 5\3", " 6\3", " 7\3", " 8\3", " 9\3", "10\3", " J\3", " Q\3", " K\3", " A\3",
	" 2\6", " 3\6", " 4\6", " 5\6", " 6\6", " 7\6", " 8\6", " 9\6", "10\6", " J\6", " Q\6", " K\6", " A\6",
};


//*********************   Дополнительное задание   ****************************************************
//Задание 11 (*)  
// Выполните задания 3 и 4 по курсовой работе 
// описание заданий находится в файлах "Задание (игра Змейка)_3 (одномерные массивы)_3.docx" и 
// "Задание (игра Змейка)_4 (+еда)_3.docs"
// Каждое задание выполняется в отдельном проекте
// Рекомендация:
// Все проекты (project), связанные с курсовой работой имеет смысл помещать в одно решение (solution)
//*****************************************************************************************************

}